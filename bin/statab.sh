#! /bin/bash
# Wrapper for Stata batch-mode which:
#  -issues an informative error msg and appropriate (possibly non-zero) return code
#  -allows an implicit -do- when called with just a do file
#  -fixes timezone when run under Cygwin
#  -remove the forced-generated log file
# Requirements: set $STATA_EXEC for the Stata executable (e.g. 'stata-mp', or 'C:/Program Files (x86)/Stata15/StataSE-64.exe').
# Set $STATA_NOQUIET to anything if you don't want to suppress logo and initialization messages

# updated from Phil Schumm's version at https://gist.github.com/pschumm/b967dfc7f723507ac4be

args=$#  # number of args

# Construct the Stata batch mode command with arguments. On Windows Stata will
# often be installed in a path with spaces (e.g. 'C:\Program Files\...') and  we
# need arrays to make paths with spaces work.

if [ -z ${STATA_EXEC+x} ]; then
    echo "STATA_EXEC is unset"
    exit 1
fi

if [ "$OS" = "Windows_NT" ]; then
    STATA_ARGS="-e";
else
    STATA_ARGS="-b";
fi

if [ -z ${STATA_NOQUIET+x} ]; then
    STATA_ARGS="$STATA_ARGS -q"
fi

STATABATCH=("$STATA_EXEC" $STATA_ARGS)

# Figure out where the log will be
cmd=""
if [ "$1" = "do" ] && [ "$args" -gt 1 ]
then
    log="`basename "$2" .do`.log"
    # mimic Stata's behavior (stata -b do "foo bar.do" -> foo.log)
    log=${log/% */.log}
# Stata requires explicit -do- command, but we relax this to permit just the
# name of a single do-file
elif [ "$args" -eq 1 ] && [ "${1##*.}" = "do" ] && [ "$1" != "do" ]
then
    cmd="do"
    log="`basename "$1" .do`.log"
    log=${log/% */.log}
else
    log="stata.log"
fi

# If you use arguments with the do-file, the log will not be found. Ususally it
# should be the name of the do-file, so we check that.
alternative_log="`basename "$1" .do`.log"

#MSVC-compiled programs run under Cygwin can't interpret the TZ
# var correctly so wrongly return UTC/GMT. Solution: unset TZ for this shell
# http://stackoverflow.com/questions/11655003/
if [ "$OS" = "Windows_NT" ]; then
    unset TZ
fi

# In batch mode, normally nothing sent to stdout but plugins can and some
# generate lots of comments.  We create a unique filename for the stdout.
# Useful for parallel make jobs.

stata_out=stata_out_$(printf "%05d\n" $RANDOM).log

"${STATABATCH[@]}" $cmd "$@" 2>&1 | tail -100 > $stata_out
rc=$?

# delete stata_out if empty
if ! [ -s $stata_out ]; then
    rm -f $stata_out
else
    #checks if var is sets vs (set to "" or unset)
    if [ -z "$STATATMP" ]; then
        if [ "$OS" = "Windows_NT" ]; then
            #under Cygwin reassigns TEMP so can't get original. Use default.
            STATATMP=$LOCALAPPDATA/Temp
        else
            STATATMP=$TMPDIR
        fi
    fi
    mv $stata_out ${STATATMP}
fi

#Return the real error by checking the log

if [ $rc == "0" ]
then
    if [ -e "$log" ]; then
        # use --max-count to avoid matching final line ("end of do-file") when
        # do-file terminates with error
        if grep --max-count=1 "^r([0-9]\+);" "$log"
        then
            rc=1
        fi
    elif [ -e "$alternative_log" ]; then
        if grep --max-count=1 "^r([0-9]\+);" "$alternative_log"
        then
            rc=1
        fi
    # If still not found, we should return an error.
    else
        echo "The logfile automatically generated by Stata was not found. Please check possible errors manually."
        rc=1
    fi
fi

#rm "$log"

exit $rc
